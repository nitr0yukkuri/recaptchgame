# recaptchgame

# プロジェクト要件定義書：Human Proof Championship
**〜 お前は人間か？それともボットか？ 0.1秒を競う究極の人間証明対戦 〜**

---

## 1. プロジェクト概要
日常のウェブ体験において、最もユーザーを苛立たせる要素の一つである「ReCAPTCHA（画像選択認証）」を、あえてオンライン対戦型の競技へと昇華させたハッカソン作品。
複数のプレイヤーが同時に同じ「お題」に挑み、誰が最も早く、正確に「人間であること」を証明できるかを競い合う。

### 1.1 開発コンセプト
- **「負の体験」のエンタメ化:** ログイン時のストレスを、勝利の快感へ。
- **圧倒的なリアルタイム性:** コンマ数秒を争う通信の低遅延化。
- **ブラックユーモア:** 最後に敗者に突きつけられる「お前はボットだ」という宣告。

---

## 2. 要件定義

### 2.1 機能要件

#### 【1】リアルタイム・マルチプレイヤー対戦機能
- **マッチングシステム:** - ルームID（合言葉）によるフレンド対戦機能。
    - ランダムなプレイヤーと即座に対戦を開始するクイックマッチ機能。
- **進捗同期:** - 相手プレイヤーが今何問目を解いているか、どの画像を選択しているかをリアルタイムで自分の画面に表示（ゴースト表示）。
- **同時スタート:** サーバーサイドで全プレイヤーの準備完了を検知し、カウントダウンとともに一斉にお題を配信。

#### 【2】ReCAPTCHA ゲームロジック
- **動的お題生成:** - 「信号機」「消火栓」「バス」「自転車」などの典型的なターゲットをランダムに設定。
    - 3x3（9枚）または 4x4（16枚）の画像グリッドを生成。
- **画像フェード演出:** - 本家を再現した「選択した画像が消えて、新しい画像がゆっくりと現れる」演出。
    - この「待ち時間」も競技時間に含まれるため、焦りによるミスを誘発する。
- **正誤判定エンジン:** - クライアントからのクリック情報をGoバックエンドで即座に検証。
    - 全ての正解パネルが選択された状態で「確認」ボタンが押されたかを厳密にチェック。

#### 【3】デバフ（お邪魔）システム
- **コンボ報酬:** 連続正解によりゲージが溜まり、相手に対して妨害を発動可能。
- **妨害内容:** - **低解像度化:** 相手の画像がモザイク状になり、判別不能になる。
    - **キャプチャ回転:** 相手の画像グリッドが回転し、座標感覚を狂わせる。
    - **画像遅延:** 画像が表示されるまでのフェード時間を意図的に長くする。

#### 【4】リザルト・ランキング
- **勝敗判定:** 指定されたセット数（例：3セット）を最短でクリアしたプレイヤーが勝利。
- **パフォーマンス統計:** 1問あたりの平均回答時間、ミスクリック率、人間度スコアの算出。

### 2.2 非機能要件
- **低レイテンシ:** WebSocketを用いた双方向通信により、アクションから反映までを100ms以内に抑える。
- **セキュリティ:** 正誤判定をフロントエンドで行わず、必ずサーバーサイドで行うことでチートを防止。
- **スケーラビリティ:** Redisによるセッション管理を行い、複数ルームの同時稼働に対応。

---

## 3. 技術構成（Technical Stack）

### 3.1 Frontend
- **Framework:** Next.js (App Router)
- **Language:** TypeScript
- **Styling:** Tailwind CSS (無機質なGoogle Material Designを模倣)
- **State Management:** Zustand (軽量な状態管理による高速レスポンス)
- **Animation:** Framer Motion (画像のフェードイン・回転演出用)

### 3.2 Backend
- **Language:** Go
- **Framework:** Echo (軽量かつ高速なルーティング)
- **Real-time:** Gorilla WebSocket
- **Validation:** サーバーサイドでの画像インデックス照合

### 3.3 Infrastructure & Managed Services
- **Platform (PaaS):** Railway (Monorepo構成)
    - **Frontend Service:** Next.jsをホスティング。
    - **Backend Service:** Goサーバーを常時稼働（WebSocket維持のため）。
- **Data/Cache:** Upstash Redis (マッチングキュー、スコア一時保存、ルーム管理)
- **Storage:** Cloudinary (お題となる画像アセットの管理)

---

## 4. システムアーキテクチャ

1. **Client (Next.js)** が WebSocket で **Server (Go)** に接続。
2. サーバーは **Redis** を使用してプレイヤーをマッチング。
3. マッチ成立後、サーバーから「画像URLリスト」と「正解条件」を JSON で配信。
4. ユーザーのアクション（クリック、送信）ごとにサーバーが検証し、結果を全プレイヤーにブロードキャスト。
5. Railway 上で Frontend と Backend が内部ネットワークまたは同一プロジェクト内で連携。

---

## 5. データ構造・プロトコル定義

### 5.1 Redis データ構造
- `room:{room_id}` (Hash)
    - `status`: `waiting`, `playing`, `finished`
    - `players`: `[player_id1, player_id2]`
    - `current_problem_id`: `string`
- `user:{user_id}:score` (String)

### 5.2 WebSocket メッセージ形式 (JSON)
```json
// クライアント -> サーバー (画像選択)
{
  "type": "SELECT_IMAGE",
  "payload": {
    "room_id": "ABC-123",
    "image_index": 4
  }
}

// サーバー -> クライアント (進捗同期)
{
  "type": "OPPONENT_PROGRESS",
  "payload": {
    "player_id": "user_xyz",
    "correct_count": 2,
    "total_needed": 3
  }
}
